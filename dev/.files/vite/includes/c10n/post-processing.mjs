/**
 * C10n post-processing plugin.
 *
 * Vite is not aware of this config file's location.
 *
 * @note PLEASE DO NOT EDIT THIS FILE!
 * @note This entire file will be updated automatically.
 * @note Instead of editing here, please review <https://github.com/clevercanyon/skeleton>.
 */

import fs from 'node:fs';
import fsp from 'node:fs/promises';
import path from 'node:path';
import { $http as $cfpꓺhttp } from '../../../../../node_modules/@clevercanyon/utilities.cfp/dist/index.js';
import { $chalk, $fs, $glob, $prettier } from '../../../../../node_modules/@clevercanyon/utilities.node/dist/index.js';
import { $brand, $crypto, $json, $mm, $obp, $preact, $str, $url } from '../../../../../node_modules/@clevercanyon/utilities/dist/index.js';
import { StandAlone as StandAlone404 } from '../../../../../node_modules/@clevercanyon/utilities/dist/preact/components/404.js';
import exclusions from '../../../bin/includes/exclusions.mjs';
import extensions from '../../../bin/includes/extensions.mjs';
import u from '../../../bin/includes/utilities.mjs';

/**
 * Configures Vite/Rollup post-processing.
 *
 * @param   props Props from vite config file driver.
 *
 * @returns       Plugin configuration.
 */
export default async ({ mode, command, isSSRBuild, projDir, distDir, pkg, env, appBaseURL, appType, targetEnv, staticDefs, pkgUpdates }) => {
    let postProcessed = false; // Initialize.
    return {
        name: 'vite-plugin-c10n-post-processing',
        enforce: 'post', // After others on this hook.

        async closeBundle(/* Rollup hook. */) {
            if (postProcessed) return;
            postProcessed = true;

            /**
             * Recompiles `./package.json`.
             */
            if (!isSSRBuild && 'build' === command) {
                u.log($chalk.gray('Recompiling `./package.json`.'));
                await u.updatePkg({ $set: pkgUpdates });
            }

            /**
             * Generates typescript type declaration file(s).
             */
            if (!isSSRBuild && 'build' === command /* Does important type checking at build time. */) {
                u.log($chalk.gray('Running TypeScript type checks.'));
                await u.spawn('npx', ['tsc']);
            }

            /**
             * Prunes `./.npmignore`s, which we don’t include in any distribution.
             *
             * We only prune `./.npmignore`s when building for production, as it’s possible there are files being
             * compiled by TypeScript that are needed for development; i.e., they need to exist in dev mode in order to
             * be capable of serving their intended purpose; e.g., dev-only utilities, runners, sandbox files, etc.
             *
             * Regarding `node_modules`. There is an exception for the case of `node_modules/assets/a16s`, used for
             * Cloudflare SSR-specific assets. See `../a16s/dir.mjs` for details. The `node_modules` folder is pruned by
             * this routine (i.e., it’s in `./.npmignore`) which is why we need to be aware of the exception. As of
             * right now, we don’t actually have to deal with the exception here, since this particular routine is
             * bypassed if `isSSRBuild`. However, please keep it in mind for future reference.
             *
             * We intentionally use our 'default' NPM ignores when pruning; i.e., as opposed to using the current and
             * potentially customized `./.npmignore` file in the current project directory. The reason is because we
             * intend to enforce our standards. For further details {@see https://o5p.me/MuskgW}.
             */
            if (!isSSRBuild && 'build' === command && 'prod' === mode) {
                for (let globOpts = [{ onlyDirectories: true }, { onlyFiles: false }], i = 0; i < globOpts.length; i++) {
                    for (const fileOrDir of await $glob.promise(exclusions.defaultNPMIgnores, { cwd: distDir, ignoreCase: true, ...globOpts[i] })) {
                        const projRelPath = path.relative(projDir, fileOrDir);

                        if (!fs.existsSync(fileOrDir)) {
                            continue; // Already pruned this in a previous iteration.
                            // e.g., when we get directory parents first, then its leaves.
                        }
                        if (
                            // These things we expect to prune regularly.
                            // Anything else warrants more attention (see below).
                            $mm.test(
                                projRelPath,
                                [
                                    ...exclusions.devIgnores, //
                                    ...exclusions.sandboxIgnores,
                                    ...exclusions.exampleIgnores,
                                    ...exclusions.docIgnores,
                                    ...exclusions.testIgnores,
                                    ...exclusions.specIgnores,
                                    ...exclusions.benchIgnores,
                                ],
                                { ignoreCase: true, dot: true },
                            )
                        ) {
                            // These things we expect to prune regularly.
                            u.log($chalk.gray('Pruning `./' + projRelPath + '`.'));
                        } else {
                            // Anything else warrants more attention (yellow).
                            u.log($chalk.yellow('Pruning `./' + projRelPath + '`.'));
                        }
                        await fsp.rm(fileOrDir, { force: true, recursive: true });
                    }
                }
            }

            /**
             * Deletes a few things that are not needed by apps running on Cloudflare Pages.
             *
             * We only prune when building for production, as it’s possible there are files being compiled by TypeScript
             * that are needed for development; i.e., they need to exist in dev mode in order to be capable of serving
             * their intended purpose; e.g., dev-only utilities, runners, sandbox files, etc.
             */
            if (!isSSRBuild && 'build' === command && 'prod' === mode && ['spa', 'mpa'].includes(appType) && ['cfp'].includes(targetEnv)) {
                for (const fileOrDir of await $glob.promise(
                    [
                        'types', // Prunes TypeScript type declarations.
                        'index.' + extensions.asBracedGlob([...extensions.byCanonical.html]),
                    ],
                    { cwd: distDir, onlyFiles: false },
                )) {
                    u.log($chalk.gray('Pruning `./' + path.relative(projDir, fileOrDir) + '`.'));
                    await fsp.rm(fileOrDir, { force: true, recursive: true });
                }
            }

            /**
             * Updates a few files that configure apps running on Cloudflare Pages.
             *
             * None of these file must exist, and none of these must contain replacement codes. We leave it up to the
             * implementation to decide. If they do not exist, or do not contain replacement codes, we assume that
             * nothing should occur. For example, it might be desirable in some cases for `./robots.txt`, `sitemap.xml`,
             * or others to be served dynamically. In which case they may not exist in these locations statically.
             */
            if (!isSSRBuild && 'build' === command && ['spa', 'mpa'].includes(appType) && ['cfp'].includes(targetEnv)) {
                for (const file of await $glob.promise(
                    [
                        '_headers', //
                        '_redirects',
                        '_routes.json',
                        '404.html',
                        'robots.txt',
                        'manifest.json',
                        'sitemap.xml',
                        'sitemaps/**/*.xml',
                    ],
                    { cwd: distDir },
                )) {
                    const fileExt = $str.trim(path.extname(file), '.');
                    const fileRelPath = path.relative(distDir, file);

                    let fileContents = fs.readFileSync(file).toString(); // Reads file contents.

                    for (const key of Object.keys(staticDefs) /* Replaces all static definition tokens. */) {
                        fileContents = fileContents.replace(new RegExp($str.escRegExp(key), 'gu'), staticDefs[key]);
                    }
                    if (['_headers'].includes(fileRelPath)) {
                        const cfpDefaultHeaders = $cfpꓺhttp.prepareDefaultHeaders({ appType, isC10n: env.APP_IS_C10N || false });
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_HEADERS__$$', cfpDefaultHeaders);
                    }
                    if (['404.html'].includes(fileRelPath)) {
                        const cfpDefault404 = '<!doctype html>' + $preact.ssr.renderToString($preact.create(StandAlone404));
                        fileContents = fileContents.replace('$$__APP_CFP_DEFAULT_404_HTML__$$', cfpDefault404);
                    }
                    if (['_headers', '_redirects', 'robots.txt'].includes(fileRelPath)) {
                        fileContents = fileContents.replace(/^#[^\n]*\n/gmu, '');
                        //
                    } else if (['json'].includes(fileExt)) {
                        fileContents = fileContents.replace(/\/\*[\s\S]*?\*\/\n?/gu, '');
                        //
                    } else if (['xml', 'html'].includes(fileExt)) {
                        fileContents = fileContents.replace(/<!--[\s\S]*?-->\n?/gu, '');
                    }
                    fileContents = $str.trim(fileContents.replace(/\n{3,}/gu, '\n\n'));

                    u.log($chalk.gray('Updating `./' + path.relative(projDir, file) + '`.'));
                    await fsp.writeFile(file, fileContents);
                }
            }

            /**
             * Generates SHA-1 manifests for JS import compatibility.
             */
            if ('build' === command && fs.existsSync(path.resolve(distDir, './vite/' + (isSSRBuild ? 'ssr-' : '') + 'manifest.json'))) {
                u.log($chalk.gray('Generating MD5-keyed ' + (isSSRBuild ? 'SSR ' : '') + 'manifest.'));

                const file = path.resolve(distDir, './vite/' + (isSSRBuild ? 'ssr-' : '') + 'manifest.json');
                const data = $json.parse((await fsp.readFile(file)).toString());
                const sha1Data = {}; // Initialize.

                for (const [key, value] of Object.entries(data)) {
                    sha1Data['x' + (await $crypto.sha1(key))] = { [key]: value };
                }
                const prettierConfig = { ...(await $prettier.resolveConfig(file)), parser: 'json' };
                await fsp.writeFile(file, await $prettier.format($json.stringify(sha1Data, { pretty: true }), prettierConfig));
            }

            /**
             * Generates PWA manifest file for SPA/MPA apps, if they don’t have one already.
             *
             * @see https://web.dev/articles/add-manifest
             */
            if (!isSSRBuild && 'build' === command && ['spa', 'mpa'].includes(appType) && appBaseURL && !fs.existsSync(path.resolve(distDir, './manifest.json'))) {
                u.log($chalk.gray('Generating PWA `./manifest.json`.'));

                const file = path.resolve(distDir, './manifest.json'),
                    brandConfigFile = path.resolve(projDir, './brand.config.mjs');

                const brand = $brand.addApp({
                        pkgName: pkg.name,
                        baseURL: appBaseURL,
                        props: await (await import(brandConfigFile)).default(),
                    }),
                    data = {
                        id: $url.toPathQueryHash($url.addQueryVar('utm_source', 'pwa', brand.url)),
                        start_url: $url.toPathQueryHash($url.addQueryVar('utm_source', 'pwa', brand.url)),
                        scope: $str.rTrim($url.parse(brand.url).pathname, '/') + '/',

                        display_override: ['browser', 'standalone', 'minimal-ui'],
                        display: 'browser', // Default and preferred presentation.

                        theme_color: brand.theme.color,
                        background_color: brand.theme.color,

                        name: brand.name,
                        short_name: brand.name,
                        description: brand.description,

                        icons: [
                            // SVGs.
                            {
                                type: 'image/svg+xml',
                                src: $url.toPathQueryHash(brand.icon.svg),
                                sizes: brand.icon.width + 'x' + brand.icon.height,
                            },
                            {
                                type: 'image/svg+xml',
                                src: $url.toPathQueryHash(brand.icon.svg),
                                sizes: '512x512', // Required size in Chrome.
                            },
                            {
                                type: 'image/svg+xml',
                                src: $url.toPathQueryHash(brand.icon.svg),
                                sizes: '192x192', // Required size in Chrome.
                            },
                            // PNGs.
                            {
                                type: 'image/png',
                                src: $url.toPathQueryHash(brand.icon.png),
                                sizes: brand.icon.width + 'x' + brand.icon.height,
                            },
                            {
                                type: 'image/png',
                                src: $url.toPathQueryHash(brand.icon.png),
                                sizes: '512x512', // Required size in Chrome.
                            },
                            {
                                type: 'image/png',
                                src: $url.toPathQueryHash(brand.icon.png),
                                sizes: '192x192', // Required size in Chrome.
                            },
                        ],
                        screenshots: [
                            // Wide.
                            {
                                type: 'image/png',
                                form_factor: 'wide',
                                src: $url.toPathQueryHash(brand.ogImage.png),
                                sizes: brand.ogImage.width + 'x' + brand.ogImage.height,
                            },
                            // Narrow.
                            {
                                type: 'image/png',
                                form_factor: 'narrow',
                                src: $url.toPathQueryHash(brand.ogImage.png),
                                sizes: brand.ogImage.width + 'x' + brand.ogImage.height,
                            },
                        ],
                    };
                const prettierConfig = { ...(await $prettier.resolveConfig(file)), parser: 'json' };
                await fsp.writeFile(file, await $prettier.format($json.stringify(data, { pretty: true }), prettierConfig));
            }

            /**
             * Generates SSR build on-the-fly internally.
             */
            if (!isSSRBuild && 'build' === command && $obp.get(pkg, 'config.c10n.&.ssrBuild.appType')) {
                u.log($chalk.gray('Running secondary SSR build routine.'));
                await u.spawn('npx', ['vite', 'build', '--mode', mode, '--ssr']);
            }

            /**
             * Generates a zip archive containing `./dist` directory.
             */
            if (!isSSRBuild && 'build' === command) {
                const zipFile = path.resolve(projDir, './.~dist.zip');
                u.log($chalk.gray('Generating `' + path.relative(projDir, zipFile) + '`.'));

                const archive = $fs.archiver('zip', { zlib: { level: 9 } });
                archive.pipe(fs.createWriteStream(zipFile));
                archive.directory(distDir + '/', false);
                await archive.finalize();
            }
        },
    };
};
